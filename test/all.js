/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */
let VTPPresaleDeployer = artifacts.require("VTPPresaleDeployer");
let VTPToken = artifacts.require("VTPToken");
let VTPPresale = artifacts.require("VTPPresale");
let IERC20 = artifacts.require("IERC20");
let _ = require('underscore')
const cache = require('../utils/cache')
const {
  BN,           // Big Number support
  expectEvent,  // Assertions for emitted events
  expectRevert, // Assertions for transactions that should fail
  ether,
  time,
} = require('@openzeppelin/test-helpers');

const closeBlockRange = 500;
const fromWei = web3.utils.fromWei

contract('VTPPresaleDeployer', async (accounts) => {
  let creatorAddress = accounts[0];
  let buyAddress = accounts[1];
  let bigBuyerAddress = accounts[2];
  let externalAddress = accounts[3];
  let lastBuyAddress = accounts[4]
  let uniswapCreatorAddress = accounts[5]
  let unprivilegedAddress = accounts[6]
  let masterAddress = accounts[7]
  /* create named accounts for contract roles */
  /**
   * @type {VtpTokenInstance}
   */
  let token = null
  /**
   * @type {VtpPresaleInstance}
   */
  let presale = null
  /**
   * @type {BN}
   */
  let startBlock = null
  /**
   * @type {BN}
   */
  let closeBlock = null

  let step = cache['step'] || 1;
  it('Reject', () => {
    return VTPPresaleDeployer.deployed()
        .then(instance => {
          return instance.publicOrExternalContractMethod(argument1, argument2, {from: externalAddress});
        })
        .then(result => {
          assert.fail();
        })
        .catch(error => {
          assert.notEqual(error.message, "assert.fail()", "Reason ...");
        });
  });

  it('Create Token and Presale Contract', async function () {
    let deployer = await VTPPresaleDeployer.deployed()
    let logs = await deployer.getPastEvents("DeployLog", {fromBlock: 0, toBlock: 'latest'})
    assert.lengthOf(logs, 1, "can not get create success log")
    token = await VTPToken.at(logs[0].args.token);
    presale = await VTPPresale.at(logs[0].args.presale);
    console.info(`Token:${token.address},Presale:${presale.address}`)
    startBlock = logs[0].args.start;
    closeBlock = startBlock.addn(closeBlockRange);
    assert.isNotEmpty(token)
    assert.isNotEmpty(presale)
  });

  it('Validate Address', async function () {
    let wallet = await presale.wallet();
    assert.equal(wallet, masterAddress)
  });

  it('Try unauthorized mining', async function () {
    try {
      await token.mint(unprivilegedAddress, web3.utils.toWei("1", "ether"))
    } catch (e) {
      assert.include(e.message, "caller is not the owner", "Error should be: caller is not the owner")
    }

    // presale.owner()

    // presale.openingBlock()
    //let presale = await VTPPresale.at('0x331515b7475479D98aC902c513CA0555a001f471')
  });

  it('Attempt to call a high-privileged function without permission', async function () {
    presale.afterClose({from: unprivilegedAddress}).catch(function (e) {
      assert.include(e.message, "caller is not the owner", "Error should be: caller is not the owner")
    })
  });

  it('Try to have permission to call the unexpired time function', function () {
    presale.afterClose().catch(function (e) {
      assert.include(e.message, "have not close", "Error should be:have not close")
    })
  });

  it('Try to buy 100ETH directly and trigger the unopened', async function () {
    await expectRevert(presale.buyTokens(buyAddress, {from: buyAddress, value: ether("100")}), 'not open')
  });

  let globalRate = new BN("50000");
  /**
   *
   * @type {Map<any, any>}
   */
  let buyCheckMap = new Map();
  let totalAmount = new BN(0)
  let buyAmount = {}

  function toRecordArray(release, block, amount) {
    return [`${release}`, `${block}`, amount.toString()]
  }

  /**
   *
   * @param {number} block
   * @param {BN} amount
   * @param address
   */
  function addBuyRecord(block, amount, address = buyAddress) {
    let list = buyCheckMap.get(address.toLowerCase());
    if (list === undefined) list = [];
    let stages = [];
    //The height during the test is step 1
    let one = toRecordArray(0, block + (140 * step), amount.muln(2).divn(10))
    let two = toRecordArray(0, block + (216 * step), amount.muln(3).divn(10))
    let three = toRecordArray(0, block + (288 * step), amount.muln(5).divn(10))
    stages.push(one, two, three);
    list.push(stages)
    buyCheckMap.set(address.toLowerCase(), list)
    totalAmount.iadd(amount)
    let buyAmountElement = buyAmount[address.toLowerCase()];
    if (buyAmountElement === undefined) buyAmountElement = new BN(0)
    buyAmount[address.toLowerCase()] = buyAmountElement.add(amount)
  }

  it('Fast forward to the startup block and buy 100ETH', async function () {
    await time.advanceBlockTo(startBlock)
    let result = await presale.buyTokens(buyAddress, {from: buyAddress, value: ether("100")});
    let log = {
      purchaser: buyAddress,
      beneficiary: buyAddress,
      value: ether("100"),
      amount: ether("100").mul(globalRate)
    }
    expectEvent(result, "TokensPurchased", log)
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount)
    assert.equal(closeBlock.addn(24 * step).toNumber(), (await presale.closingBlock()).toNumber())
  });

  //todo:Try to buy a quantity within 0~10wei

  it('Buy 350ETH again for a total of 450', async function () {
    let result = await presale.buyTokens(buyAddress, {from: buyAddress, value: ether("350")});
    /**
     * @type {TokensPurchased.args}
     */
    let log = result.logs.find((value => {
      return value.event === "TokensPurchased"
    })).args
    assert.isTrue(log.value.mul(globalRate).eq(log.amount), "Incorrect conversion ratio")
    assert.isTrue(log.amount.eq(ether("350").mul(globalRate)), "Incorrect conversion result")
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount)
    assert.equal(closeBlock.addn(24 * 4 * step).toNumber(), (await presale.closingBlock()).toNumber())
  });

  it('Buy 100 ETH again, the total is 550, the rate change will not be triggered at this time', async function () {
    let result = await presale.buyTokens(buyAddress, {from: buyAddress, value: ether("100")});
    /**
     * @type {TokensPurchased.args}
     */
    let log = result.logs.find((value => {
      return value.event === "TokensPurchased"
    })).args
    assert.isTrue(log.value.mul(globalRate).eq(log.amount), "Incorrect conversion ratio")
    assert.isTrue(log.amount.eq(ether("100").mul(globalRate)), "Incorrect conversion result")
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount)
    assert.equal(closeBlock.addn(24 * 5 * step).toNumber(), (await presale.closingBlock()).toNumber())
  });

  it('Get the rate. At this time, the rate should be reduced by 1000 to 49000', async function () {
    let rate = await presale.rate();
    assert.equal(rate.toString(), globalRate.isubn(1000).toString(), "Incorrect amount of attenuation")
  });

  it('Continue to buy 100 ETH, totaling 650. At this time, the rate change has been triggered. The amount obtained should be 4,900,000', async function () {
    let result = await presale.buyTokens(buyAddress, {from: buyAddress, value: ether("100")});
    /**
     * @type {TokensPurchased.args}
     */
    let log = result.logs.find((value => {
      return value.event === "TokensPurchased"
    })).args
    assert.isTrue(log.value.mul(globalRate).eq(log.amount), "Wrong conversion ratio")
    assert.isTrue(log.amount.eq(ether("100").mul(globalRate)), "Incorrect conversion result")
    assert.equal(globalRate.toString(), "49000", "Rate result is wrong")
    assert.equal(new BN("100").mul(globalRate).toString(), "4900000", "Get the wrong amount")
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount)
  });

  function list2ArrayRecords(list) {
    assert.isArray(list, "Must be an array")
    assert.isTrue(list.length % 9 === 0, "Unreasonable length")
    for (let i = 0; i < list.length; i++) {
      list[i] = list[i].toString();
    }
    let result = _.chunk(list, 9)
    result = _.map(result, function (one) {
      return _.chunk(one, 3)
    })
    return result
  }

  it('Get purchase record', async function () {
    let records = await presale.buyRecords({from: buyAddress});
    assert.deepEqual(list2ArrayRecords(records), buyCheckMap.get(buyAddress.toLowerCase()), "Data is not equal")
  });

  it('Now 650 other users directly purchase 2900 and need to pay 2250 and the rate should be 45000', async function () {
    let receipt = await presale.buyTokens(bigBuyerAddress, {from: bigBuyerAddress, value: ether("2250")})
    let log = {
      purchaser: bigBuyerAddress,
      beneficiary: bigBuyerAddress,
      value: ether("2250"),
      amount: ether("2250").mul(globalRate)
    }
    expectEvent(receipt, "TokensPurchased", log)
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount, bigBuyerAddress)
    assert.equal("45000", (await presale.rate()).toString(), "Incorrect rate")
    globalRate = new BN("45000")
    assert.equal(closeBlock.addn(24 * (5 + 4) * step).toNumber(), (await presale.closingBlock()).toNumber())
  });

  it('Purchase the quantity exceeding the limit, the total amount is 3100', async function () {
    let receipt = await presale.buyTokens(lastBuyAddress, {from: lastBuyAddress, value: ether("200")})
    let log = {
      purchaser: lastBuyAddress,
      beneficiary: lastBuyAddress,
      value: ether("200"),
      amount: ether("200").mul(globalRate)
    }
    expectEvent(receipt, "TokensPurchased", log)
    addBuyRecord(await web3.eth.getBlockNumber(), log.amount, lastBuyAddress)
    assert.equal(closeBlock.addn(24 * (5 + 5) * step).toNumber(), (await presale.closingBlock()).toNumber())
    closeBlock.iaddn(24 * (5 + 5) * step)
  });

  it('Continue to buy 100 after the sale', async function () {
    await expectRevert(presale.buyTokens(lastBuyAddress, {from: lastBuyAddress, value: ether("100")}), "Exceed maximum")
  });

  it('Verify the final rate and storeValue and storeTokenValue', async function () {
    let rate = await presale.rate();
    assert.equal(rate.toString(), "44000", "Incorrect rate")
    let data = await presale.storeAmount()
    assert.equal(data[1].toString(), totalAmount.toString(), "Inconsistent quantities")
  });

  it('Try to release before reaching the end height', async function () {
    let currency = await web3.eth.getBlockNumber()
    assert.isBelow(currency,startBlock.toNumber() + closeBlockRange,"Height error")
    await expectRevert(presale.afterClose(),"have not close")
  });

  it('Try to call release directly', async function () {
    await expectRevert(presale.release({from:buyAddress}),"Locking")
  });

  it('Attempt to reach height to release but was locked and refused', async function () {
    let records = buyCheckMap.get(buyAddress.toLowerCase())
    let firstReleaseBlock = records[0][0][1] - -1;
    await time.advanceBlockTo(firstReleaseBlock)

    await expectRevert(presale.afterClose(),"have not close")
  });

  function toEther(wei) {
    return web3.utils.fromWei(wei, "ether").toString()
  }

  let lastLiquidity = 0;

  it('Try to be released by the team', async function () {
    if(step !== 1) await time.advanceBlockTo(closeBlock)
    let receipt = await presale.afterClose()
    assert.equal(receipt.logs.length, 1, "Incorrect event length")
    assert.equal((await token.balanceOf(presale.address)).toString(), "0");
    assert.equal(await web3.eth.getBalance(presale.address), "0")
    assert.notEqual(toEther(await web3.eth.getBalance(masterAddress)), "0")
    assert.notEqual(toEther(await token.balanceOf(masterAddress)), "0")
    let pair = await IERC20.at(await presale.getPair())
    lastLiquidity = await pair.balanceOf(presale.address)
    assert.notEqual(toEther(lastLiquidity), "0")
  });

  it('Try to release 5% daily', async function () {
    let now = await web3.eth.getBlockNumber();
    if(step !== 1) await time.advanceBlockTo(now + 216 * step + 1)
    await expectEvent(await presale.projectRelease(), "DailyRelease");

    let pair = await IERC20.at(await presale.getPair())
    let nowLiquidity = await pair.balanceOf(presale.address);
    assert.isTrue(nowLiquidity.lt(lastLiquidity))
  });


  function getReleasePart(block, address) {
    let records = [];
    let result = buyCheckMap.get(address.toLowerCase());
    for (let i = 0; i < result.length; i++) {
      let record = result[i];
      for (let j = 0; j < record.length; j++) {
        let stage = record[j];
        if (stage.length > 0 && parseInt(stage[1]) <= block) {
          records.push([
            address.toLowerCase(),
            stage[2],
            `${j}`,
            `${i}`
          ])
          record[j] = [];
        }
        result[i] = record;
      }
      buyCheckMap.set(address.toLowerCase(),result)
    }

    return records;
  }

  function dealEvent(logs) {
    let records = [];
    for (let one of logs) {
      if (one.event === "ReleaseVTP") {
        records.push([
          one.args.beneficiary.toLowerCase(),
          one.args.amount.toString(),
          one.args.stage.toString(),
          one.args.id.toString(),
        ])
      }
    }
    return records
  }

  it('Get the current amount that can be released', async function () {
    let now = await web3.eth.getBlockNumber() + 250;
    await time.advanceBlockTo(now)
    let release = getReleasePart(now, buyAddress)
    assert.deepEqual(release,dealEvent((await presale.release({from: buyAddress})).logs))
  });

  it('Release again return empty', async function () {
    assert.lengthOf((await presale.release({from: buyAddress})).logs,0)
  });

  it('Jump 150 blocks again', async function () {
    let now = await web3.eth.getBlockNumber() + 250;
    await time.advanceBlockTo(now)
    let release = getReleasePart(now, buyAddress)
    let blockRelease = dealEvent((await presale.release({from: buyAddress})).logs)
    assert.deepEqual(release,blockRelease)
  });

  it('Jump 10 blocks and release again to be empty', async function () {
    let now = await web3.eth.getBlockNumber() + 10;
    await time.advanceBlockTo(now)
    assert.lengthOf((await presale.release({from: buyAddress})).logs,0)
  });

  function allReleaseDone(records){
    _.forEach(records,(value =>{
      _.forEach(value,one=>{
        if (one[0] !== '1') return false;
      })
    }))
    return true
  }

  it('Check the release list', async function () {
    let receipt = await presale.buyRecords({from:buyAddress})
    assert.isTrue(allReleaseDone(list2ArrayRecords(receipt)))
  });

  it('Check large users',async function () {
    assert.deepEqual(buyCheckMap.get(bigBuyerAddress.toLowerCase()),list2ArrayRecords(await presale.buyRecords({from:bigBuyerAddress})))
  });

  it('Release large users', async function () {
    let now = await web3.eth.getBlockNumber()
    let release = getReleasePart(now, bigBuyerAddress)
    assert.deepEqual(release,dealEvent((await presale.release({from: bigBuyerAddress})).logs))
  });

  it('Release again empty', async function () {
    assert.lengthOf((await presale.release({from: bigBuyerAddress})).logs,0)
  });

  it('Check the large user release list', async function () {
    let receipt = await presale.buyRecords({from:bigBuyerAddress})
    assert.isTrue(allReleaseDone(list2ArrayRecords(receipt)))
  });

  it('Check the number of token balances of each address', async function () {
    let buyer = await token.balanceOf(buyAddress);
    let bigBuyer = await token.balanceOf(bigBuyerAddress);
    let master = await token.balanceOf(masterAddress)
    assert.equal(buyer.toString(),buyAmount[buyAddress.toLowerCase()].toString())
    assert.equal(bigBuyer.toString(),buyAmount[bigBuyerAddress.toLowerCase()].toString())
    let amounts = await presale.storeAmount();
    assert.isTrue(amounts[1].lt(master))
  });
});
